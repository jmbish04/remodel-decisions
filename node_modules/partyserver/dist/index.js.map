{"version":3,"file":"index.js","names":["#cache","state: T","setState","state: DurableObjectState","tag?: string","socket: WebSocket","#connections","controller: DurableObjectState","defaultEnv","env","#ParentClass","#_props","#_name","connection: Connection","state: T","#connectionManager","#attachSocketEventHandlers","#status","#initialize","e","#_longErrorAboutNameThrown","#sendMessageToConnection","timeoutId: ReturnType<typeof setTimeout>"],"sources":["../src/connection.ts","../src/index.ts"],"sourcesContent":["// Polyfill WebSocket status code constants for environments that don't have them\n// in order to support libraries that expect standards-compatible WebSocket\n// implementations (e.g. PartySocket)\n\nimport type {\n  Connection,\n  ConnectionSetStateFn,\n  ConnectionState\n} from \"./types\";\n\nif (!(\"OPEN\" in WebSocket)) {\n  const WebSocketStatus = {\n    // @ts-expect-error\n    CONNECTING: WebSocket.READY_STATE_CONNECTING,\n    // @ts-expect-error\n    OPEN: WebSocket.READY_STATE_OPEN,\n    // @ts-expect-error\n    CLOSING: WebSocket.READY_STATE_CLOSING,\n    // @ts-expect-error\n    CLOSED: WebSocket.READY_STATE_CLOSED\n  };\n\n  Object.assign(WebSocket, WebSocketStatus);\n  // @ts-expect-error\n  Object.assign(WebSocket.prototype, WebSocketStatus);\n}\n\n/**\n * Store both platform attachments and user attachments in different namespaces\n */\ntype ConnectionAttachments = {\n  __pk: {\n    id: string;\n    // TODO: remove this once we have\n    // durable object level setState\n    server: string;\n  };\n  __user?: unknown;\n};\n\nfunction tryGetPartyServerMeta(\n  ws: WebSocket\n): ConnectionAttachments[\"__pk\"] | null {\n  try {\n    // Avoid AttachmentCache.get() here: hibernated sockets accepted outside\n    // PartyServer can have an attachment without a __pk namespace.\n    const attachment = WebSocket.prototype.deserializeAttachment.call(\n      ws\n    ) as unknown;\n    if (!attachment || typeof attachment !== \"object\") {\n      return null;\n    }\n    if (!(\"__pk\" in attachment)) {\n      return null;\n    }\n    const pk = (attachment as ConnectionAttachments).__pk as unknown;\n    if (!pk || typeof pk !== \"object\") {\n      return null;\n    }\n    const { id, server } = pk as { id?: unknown; server?: unknown };\n    if (typeof id !== \"string\" || typeof server !== \"string\") {\n      return null;\n    }\n    return pk as ConnectionAttachments[\"__pk\"];\n  } catch {\n    return null;\n  }\n}\n\nexport function isPartyServerWebSocket(ws: WebSocket): boolean {\n  return tryGetPartyServerMeta(ws) !== null;\n}\n\n/**\n * Cache websocket attachments to avoid having to rehydrate them on every property access.\n */\nclass AttachmentCache {\n  #cache = new WeakMap<WebSocket, ConnectionAttachments>();\n\n  get(ws: WebSocket): ConnectionAttachments {\n    let attachment = this.#cache.get(ws);\n    if (!attachment) {\n      attachment = WebSocket.prototype.deserializeAttachment.call(\n        ws\n      ) as ConnectionAttachments;\n      if (attachment !== undefined) {\n        this.#cache.set(ws, attachment);\n      } else {\n        throw new Error(\n          \"Missing websocket attachment. This is most likely an issue in PartyServer, please open an issue at https://github.com/cloudflare/partykit/issues\"\n        );\n      }\n    }\n\n    return attachment;\n  }\n\n  set(ws: WebSocket, attachment: ConnectionAttachments) {\n    this.#cache.set(ws, attachment);\n    WebSocket.prototype.serializeAttachment.call(ws, attachment);\n  }\n}\n\nconst attachments = new AttachmentCache();\nconst connections = new WeakSet<Connection>();\nconst isWrapped = (ws: WebSocket): ws is Connection => {\n  return connections.has(ws as Connection);\n};\n\n/**\n * Wraps a WebSocket with Connection fields that rehydrate the\n * socket attachments lazily only when requested.\n */\nexport const createLazyConnection = (\n  ws: WebSocket | Connection\n): Connection => {\n  if (isWrapped(ws)) {\n    return ws;\n  }\n\n  // if state was set on the socket before initializing the connection,\n  // capture it here so we can persist it again\n  // biome-ignore lint/suspicious/noImplicitAnyLet: it's fine\n  let initialState;\n  if (\"state\" in ws) {\n    initialState = ws.state;\n    delete ws.state;\n  }\n\n  const connection = Object.defineProperties(ws, {\n    id: {\n      get() {\n        return attachments.get(ws).__pk.id;\n      }\n    },\n    server: {\n      get() {\n        return attachments.get(ws).__pk.server;\n      }\n    },\n    socket: {\n      get() {\n        return ws;\n      }\n    },\n    state: {\n      get() {\n        return ws.deserializeAttachment() as ConnectionState<unknown>;\n      }\n    },\n    setState: {\n      value: function setState<T>(setState: T | ConnectionSetStateFn<T>) {\n        let state: T;\n        if (setState instanceof Function) {\n          state = setState((this as Connection<T>).state);\n        } else {\n          state = setState;\n        }\n\n        ws.serializeAttachment(state);\n        return state as ConnectionState<T>;\n      }\n    },\n\n    deserializeAttachment: {\n      value: function deserializeAttachment<T = unknown>() {\n        const attachment = attachments.get(ws);\n        return (attachment.__user ?? null) as T;\n      }\n    },\n\n    serializeAttachment: {\n      value: function serializeAttachment<T = unknown>(attachment: T) {\n        const setting = {\n          ...attachments.get(ws),\n          __user: attachment ?? null\n        };\n\n        attachments.set(ws, setting);\n      }\n    }\n  }) as Connection;\n\n  if (initialState) {\n    connection.setState(initialState);\n  }\n\n  connections.add(connection);\n  return connection;\n};\n\nclass HibernatingConnectionIterator<T> implements IterableIterator<\n  Connection<T>\n> {\n  private index = 0;\n  private sockets: WebSocket[] | undefined;\n  constructor(\n    private state: DurableObjectState,\n    private tag?: string\n  ) {}\n\n  [Symbol.iterator](): IterableIterator<Connection<T>> {\n    return this;\n  }\n\n  next(): IteratorResult<Connection<T>, number | undefined> {\n    const sockets =\n      // biome-ignore lint/suspicious/noAssignInExpressions: it's fine\n      this.sockets ?? (this.sockets = this.state.getWebSockets(this.tag));\n\n    let socket: WebSocket;\n    // biome-ignore lint/suspicious/noAssignInExpressions: it's fine\n    while ((socket = sockets[this.index++])) {\n      // only yield open sockets to match non-hibernating behaviour\n      if (socket.readyState === WebSocket.READY_STATE_OPEN) {\n        // Durable Objects hibernation APIs allow storing arbitrary sockets via\n        // `state.acceptWebSocket()`. Those sockets won't have PartyServer's\n        // `__pk` attachment namespace and must be ignored.\n        if (!isPartyServerWebSocket(socket)) {\n          continue;\n        }\n        const value = createLazyConnection(socket) as Connection<T>;\n        return { done: false, value };\n      }\n    }\n\n    // reached the end of the iteratee\n    return { done: true, value: undefined };\n  }\n}\n\nexport interface ConnectionManager {\n  getCount(): number;\n  getConnection<TState>(id: string): Connection<TState> | undefined;\n  getConnections<TState>(tag?: string): IterableIterator<Connection<TState>>;\n  accept(\n    connection: Connection,\n    options: { tags: string[]; server: string }\n  ): Connection;\n}\n\n/**\n * When not using hibernation, we track active connections manually.\n */\nexport class InMemoryConnectionManager<TState> implements ConnectionManager {\n  #connections: Map<string, Connection> = new Map();\n  tags: WeakMap<Connection, string[]> = new WeakMap();\n\n  getCount() {\n    return this.#connections.size;\n  }\n\n  getConnection<T = TState>(id: string) {\n    return this.#connections.get(id) as Connection<T> | undefined;\n  }\n\n  *getConnections<T = TState>(tag?: string): IterableIterator<Connection<T>> {\n    if (!tag) {\n      yield* this.#connections\n        .values()\n        .filter(\n          (c) => c.readyState === WebSocket.READY_STATE_OPEN\n        ) as IterableIterator<Connection<T>>;\n      return;\n    }\n\n    // simulate DurableObjectState.getWebSockets(tag) behaviour\n    for (const connection of this.#connections.values()) {\n      const connectionTags = this.tags.get(connection) ?? [];\n      if (connectionTags.includes(tag)) {\n        yield connection as Connection<T>;\n      }\n    }\n  }\n\n  accept(connection: Connection, options: { tags: string[]; server: string }) {\n    connection.accept();\n\n    this.#connections.set(connection.id, connection);\n    this.tags.set(connection, [\n      // make sure we have id tag\n      connection.id,\n      ...options.tags.filter((t) => t !== connection.id)\n    ]);\n\n    const removeConnection = () => {\n      this.#connections.delete(connection.id);\n      connection.removeEventListener(\"close\", removeConnection);\n      connection.removeEventListener(\"error\", removeConnection);\n    };\n    connection.addEventListener(\"close\", removeConnection);\n    connection.addEventListener(\"error\", removeConnection);\n\n    return connection;\n  }\n}\n\n/**\n * When opting into hibernation, the platform tracks connections for us.\n */\nexport class HibernatingConnectionManager<TState> implements ConnectionManager {\n  constructor(private controller: DurableObjectState) {}\n\n  getCount() {\n    // Only count sockets managed by PartyServer. Other hibernated sockets may\n    // exist on the same Durable Object via `state.acceptWebSocket()`.\n    let count = 0;\n    for (const ws of this.controller.getWebSockets()) {\n      if (isPartyServerWebSocket(ws)) count++;\n    }\n    return count;\n  }\n\n  getConnection<T = TState>(id: string) {\n    // TODO: Should we cache the connections?\n    const sockets = this.controller.getWebSockets(id);\n    const matching = sockets.filter((ws) => {\n      return tryGetPartyServerMeta(ws)?.id === id;\n    });\n\n    if (matching.length === 0) return undefined;\n    if (matching.length === 1)\n      return createLazyConnection(matching[0]) as Connection<T>;\n\n    throw new Error(\n      `More than one connection found for id ${id}. Did you mean to use getConnections(tag) instead?`\n    );\n  }\n\n  getConnections<T = TState>(tag?: string | undefined) {\n    return new HibernatingConnectionIterator<T>(this.controller, tag);\n  }\n\n  accept(connection: Connection, options: { tags: string[]; server: string }) {\n    // dedupe tags in case user already provided id tag\n    const tags = [\n      connection.id,\n      ...options.tags.filter((t) => t !== connection.id)\n    ];\n\n    // validate tags against documented restrictions\n    // shttps://developers.cloudflare.com/durable-objects/api/hibernatable-websockets-api/#state-methods-for-websockets\n    if (tags.length > 10) {\n      throw new Error(\n        \"A connection can only have 10 tags, including the default id tag.\"\n      );\n    }\n\n    for (const tag of tags) {\n      if (typeof tag !== \"string\") {\n        throw new Error(`A connection tag must be a string. Received: ${tag}`);\n      }\n      if (tag === \"\") {\n        throw new Error(\"A connection tag must not be an empty string.\");\n      }\n      if (tag.length > 256) {\n        throw new Error(\"A connection tag must not exceed 256 characters\");\n      }\n    }\n\n    this.controller.acceptWebSocket(connection, tags);\n    connection.serializeAttachment({\n      __pk: {\n        id: connection.id,\n        server: options.server\n      },\n      __user: null\n    });\n\n    return createLazyConnection(connection);\n  }\n}\n","// rethink error handling, how to pass it on to the client\n// rethink oBC/oBR\n// push for durable.setState (in addition to connection.setState)\n\nimport { DurableObject, env as defaultEnv } from \"cloudflare:workers\";\nimport { nanoid } from \"nanoid\";\n\nimport {\n  createLazyConnection,\n  HibernatingConnectionManager,\n  InMemoryConnectionManager,\n  isPartyServerWebSocket\n} from \"./connection\";\n\nimport type { ConnectionManager } from \"./connection\";\nimport type {\n  Connection,\n  ConnectionContext,\n  ConnectionSetStateFn,\n  ConnectionState\n} from \"./types\";\n\nexport * from \"./types\";\n\nexport type WSMessage = ArrayBuffer | ArrayBufferView | string;\n\n// Let's cache the server namespace map\n// so we don't call it on every request\nconst serverMapCache = new WeakMap<\n  object,\n  Record<string, DurableObjectNamespace>\n>();\n\n/**\n * For a given server namespace, create a server with a name.\n */\nexport async function getServerByName<\n  Env extends Cloudflare.Env = Cloudflare.Env,\n  T extends Server<Env> = Server<Env>,\n  Props extends Record<string, unknown> = Record<string, unknown>\n>(\n  serverNamespace: DurableObjectNamespace<T>,\n  name: string,\n  options?: {\n    jurisdiction?: DurableObjectJurisdiction;\n    locationHint?: DurableObjectLocationHint;\n    props?: Props;\n  }\n): Promise<DurableObjectStub<T>> {\n  if (options?.jurisdiction) {\n    serverNamespace = serverNamespace.jurisdiction(options.jurisdiction);\n  }\n\n  const id = serverNamespace.idFromName(name);\n  const stub = serverNamespace.get(id, options);\n\n  // TODO: fix this to use RPC\n\n  const req = new Request(\n    \"http://dummy-example.cloudflare.com/cdn-cgi/partyserver/set-name/\"\n  );\n\n  req.headers.set(\"x-partykit-room\", name);\n\n  if (options?.props) {\n    req.headers.set(\"x-partykit-props\", JSON.stringify(options?.props));\n  }\n\n  // unfortunately we have to await this\n  await stub\n    .fetch(req)\n    // drain body\n    .then((res) => res.text())\n    .catch((e) => {\n      console.error(\"Could not set server name:\", e);\n    });\n\n  return stub;\n}\n\nfunction camelCaseToKebabCase(str: string): string {\n  // If string is all uppercase, convert to lowercase\n  if (str === str.toUpperCase() && str !== str.toLowerCase()) {\n    return str.toLowerCase().replace(/_/g, \"-\");\n  }\n\n  // Otherwise handle camelCase to kebab-case\n  let kebabified = str.replace(\n    /[A-Z]/g,\n    (letter) => `-${letter.toLowerCase()}`\n  );\n  kebabified = kebabified.startsWith(\"-\") ? kebabified.slice(1) : kebabified;\n  // Convert any remaining underscores to hyphens and remove trailing -'s\n  return kebabified.replace(/_/g, \"-\").replace(/-$/, \"\");\n}\nexport interface PartyServerOptions<\n  // biome-ignore lint/correctness/noUnusedVariables: it's ok, we'll remove this in the next major\n  Env = Cloudflare.Env,\n  Props = Record<string, unknown>\n> {\n  prefix?: string;\n  jurisdiction?: DurableObjectJurisdiction;\n  locationHint?: DurableObjectLocationHint;\n  props?: Props;\n  onBeforeConnect?: (\n    req: Request,\n    lobby: {\n      party: string;\n      name: string;\n    }\n  ) => Response | Request | void | Promise<Response | Request | void>;\n  onBeforeRequest?: (\n    req: Request,\n    lobby: {\n      party: string;\n      name: string;\n    }\n  ) =>\n    | Response\n    | Request\n    | void\n    | Promise<Response | Request | undefined | void>;\n}\n/**\n * A utility function for PartyKit style routing.\n */\nexport async function routePartykitRequest<\n  Env extends Cloudflare.Env = Cloudflare.Env,\n  T extends Server<Env> = Server<Env>,\n  Props extends Record<string, unknown> = Record<string, unknown>\n>(\n  req: Request,\n  env: Env = defaultEnv as Env,\n  options?: PartyServerOptions<Env, Props>\n): Promise<Response | null> {\n  if (!serverMapCache.has(env)) {\n    serverMapCache.set(\n      env,\n      Object.entries(env).reduce((acc, [k, v]) => {\n        if (\n          v &&\n          typeof v === \"object\" &&\n          \"idFromName\" in v &&\n          typeof v.idFromName === \"function\"\n        ) {\n          Object.assign(acc, { [camelCaseToKebabCase(k)]: v });\n          return acc;\n        }\n        return acc;\n      }, {})\n    );\n  }\n  const map = serverMapCache.get(env) as unknown as Record<\n    string,\n    DurableObjectNamespace<T>\n  >;\n\n  const prefix = options?.prefix || \"parties\";\n  const prefixParts = prefix.split(\"/\");\n\n  const url = new URL(req.url);\n  const parts = url.pathname.split(\"/\").filter(Boolean); // Remove empty strings\n\n  // Check if the URL starts with the prefix\n  const prefixMatches = prefixParts.every(\n    (part, index) => parts[index] === part\n  );\n  if (!prefixMatches || parts.length < prefixParts.length + 2) {\n    return null;\n  }\n\n  const namespace = parts[prefixParts.length];\n  const name = parts[prefixParts.length + 1];\n\n  if (name && namespace) {\n    if (!map[namespace]) {\n      if (namespace === \"main\") {\n        console.warn(\n          \"You appear to be migrating a PartyKit project to PartyServer.\"\n        );\n        console.warn(`PartyServer doesn't have a \"main\" party by default. Try adding this to your PartySocket client:\\n \nparty: \"${camelCaseToKebabCase(Object.keys(map)[0])}\"`);\n      } else {\n        console.error(`The url ${req.url}  with namespace \"${namespace}\" and name \"${name}\" does not match any server namespace. \nDid you forget to add a durable object binding to the class ${namespace[0].toUpperCase() + namespace.slice(1)} in your wrangler.jsonc?`);\n      }\n      // we should return a response with a status code that it's an invalid request\n      return new Response(\"Invalid request\", { status: 400 });\n    }\n\n    let doNamespace = map[namespace];\n    if (options?.jurisdiction) {\n      doNamespace = doNamespace.jurisdiction(options.jurisdiction);\n    }\n\n    const id = doNamespace.idFromName(name);\n    const stub = doNamespace.get(id, options);\n\n    // const stub = await getServerByName(map[namespace], name, options); // TODO: fix this\n    // make a new request with additional headers\n\n    req = new Request(req);\n    req.headers.set(\"x-partykit-room\", name);\n    req.headers.set(\"x-partykit-namespace\", namespace);\n    if (options?.jurisdiction) {\n      req.headers.set(\"x-partykit-jurisdiction\", options.jurisdiction);\n    }\n\n    if (options?.props) {\n      req.headers.set(\"x-partykit-props\", JSON.stringify(options?.props));\n    }\n\n    if (req.headers.get(\"Upgrade\")?.toLowerCase() === \"websocket\") {\n      if (options?.onBeforeConnect) {\n        const reqOrRes = await options.onBeforeConnect(req, {\n          party: namespace,\n          name\n        });\n        if (reqOrRes instanceof Request) {\n          req = reqOrRes;\n        } else if (reqOrRes instanceof Response) {\n          return reqOrRes;\n        }\n      }\n    } else {\n      if (options?.onBeforeRequest) {\n        const reqOrRes = await options.onBeforeRequest(req, {\n          party: namespace,\n          name\n        });\n        if (reqOrRes instanceof Request) {\n          req = reqOrRes;\n        } else if (reqOrRes instanceof Response) {\n          return reqOrRes;\n        }\n      }\n    }\n\n    return stub.fetch(req);\n  } else {\n    return null;\n  }\n}\n\nexport class Server<\n  Env extends Cloudflare.Env = Cloudflare.Env,\n  Props extends Record<string, unknown> = Record<string, unknown>\n> extends DurableObject<Env> {\n  static options = {\n    hibernate: false\n  };\n\n  #status: \"zero\" | \"starting\" | \"started\" = \"zero\";\n\n  #ParentClass: typeof Server = Object.getPrototypeOf(this).constructor;\n\n  #connectionManager: ConnectionManager = this.#ParentClass.options.hibernate\n    ? new HibernatingConnectionManager(this.ctx)\n    : new InMemoryConnectionManager();\n\n  /**\n   * Execute SQL queries against the Server's database\n   * @template T Type of the returned rows\n   * @param strings SQL query template strings\n   * @param values Values to be inserted into the query\n   * @returns Array of query results\n   */\n  sql<T = Record<string, string | number | boolean | null>>(\n    strings: TemplateStringsArray,\n    ...values: (string | number | boolean | null)[]\n  ) {\n    let query = \"\";\n    try {\n      // Construct the SQL query with placeholders\n      query = strings.reduce(\n        (acc, str, i) => acc + str + (i < values.length ? \"?\" : \"\"),\n        \"\"\n      );\n\n      // Execute the SQL query with the provided values\n      return [...this.ctx.storage.sql.exec(query, ...values)] as T[];\n    } catch (e) {\n      console.error(`failed to execute sql query: ${query}`, e);\n      throw this.onException(e);\n    }\n  }\n\n  // biome-ignore lint/complexity/noUselessConstructor: it's fine\n  constructor(ctx: DurableObjectState, env: Env) {\n    super(ctx, env);\n\n    // TODO: throw error if any of\n    // broadcast/getConnection/getConnections/getConnectionTags\n    // fetch/webSocketMessage/webSocketClose/webSocketError/alarm\n    // have been overridden\n  }\n\n  /**\n   * Handle incoming requests to the server.\n   */\n  async fetch(request: Request): Promise<Response> {\n    // Set the props in-mem if the request included them.\n    const props = request.headers.get(\"x-partykit-props\");\n    if (props) {\n      try {\n        this.#_props = JSON.parse(props);\n      } catch {\n        // This should never happen but log it just in case\n        console.error(\"Internal error parsing context props.\");\n      }\n    }\n\n    if (!this.#_name) {\n      // This is temporary while we solve https://github.com/cloudflare/workerd/issues/2240\n\n      // get namespace and room from headers\n      // const namespace = request.headers.get(\"x-partykit-namespace\");\n      const room = request.headers.get(\"x-partykit-room\");\n      if (\n        // !namespace ||\n        !room\n      ) {\n        throw new Error(`Missing namespace or room headers when connecting to ${this.#ParentClass.name}.\nDid you try connecting directly to this Durable Object? Try using getServerByName(namespace, id) instead.`);\n      }\n      await this.setName(room);\n    }\n\n    try {\n      const url = new URL(request.url);\n\n      // TODO: this is a hack to set the server name,\n      // it'll be replaced with RPC later\n      if (url.pathname === \"/cdn-cgi/partyserver/set-name/\") {\n        // we can just return a 200 for now\n        return Response.json({ ok: true });\n      }\n\n      // Handle keep-alive WebSocket endpoint (internal use for waitUntil)\n      if (url.pathname === \"/cdn-cgi/partyserver/keep-alive/\") {\n        if (request.headers.get(\"Upgrade\")?.toLowerCase() === \"websocket\") {\n          const { 0: client, 1: server } = new WebSocketPair();\n          // Always use hibernation API for keep-alive (efficient, internal-only)\n          this.ctx.acceptWebSocket(server, [\"partyserver-keepalive\"]);\n          return new Response(null, { status: 101, webSocket: client });\n        }\n        return new Response(\"WebSocket required\", { status: 426 });\n      }\n\n      if (request.headers.get(\"Upgrade\")?.toLowerCase() !== \"websocket\") {\n        return await this.onRequest(request);\n      } else {\n        // Create the websocket pair for the client\n        const { 0: clientWebSocket, 1: serverWebSocket } = new WebSocketPair();\n        let connectionId = url.searchParams.get(\"_pk\");\n        if (!connectionId) {\n          connectionId = nanoid();\n        }\n\n        let connection: Connection = Object.assign(serverWebSocket, {\n          id: connectionId,\n          server: this.name,\n          state: null as unknown as ConnectionState<unknown>,\n          setState<T = unknown>(setState: T | ConnectionSetStateFn<T>) {\n            let state: T;\n            if (setState instanceof Function) {\n              state = setState(this.state as ConnectionState<T>);\n            } else {\n              state = setState;\n            }\n\n            // TODO: deepFreeze object?\n            this.state = state as ConnectionState<T>;\n            return this.state;\n          }\n        });\n\n        const ctx = { request };\n\n        const tags = await this.getConnectionTags(connection, ctx);\n\n        // Accept the websocket connection\n        connection = this.#connectionManager.accept(connection, {\n          tags,\n          server: this.name\n        });\n\n        if (!this.#ParentClass.options.hibernate) {\n          this.#attachSocketEventHandlers(connection);\n        }\n        await this.onConnect(connection, ctx);\n\n        return new Response(null, { status: 101, webSocket: clientWebSocket });\n      }\n    } catch (err) {\n      console.error(\n        `Error in ${this.#ParentClass.name}:${this.name} fetch:`,\n        err\n      );\n      if (!(err instanceof Error)) throw err;\n      if (request.headers.get(\"Upgrade\") === \"websocket\") {\n        // Annoyingly, if we return an HTTP error in response to a WebSocket request, Chrome devtools\n        // won't show us the response body! So... let's send a WebSocket response with an error\n        // frame instead.\n        const pair = new WebSocketPair();\n        pair[1].accept();\n        pair[1].send(JSON.stringify({ error: err.stack }));\n        pair[1].close(1011, \"Uncaught exception during session setup\");\n        return new Response(null, { status: 101, webSocket: pair[0] });\n      } else {\n        return new Response(err.stack, { status: 500 });\n      }\n    }\n  }\n\n  async webSocketMessage(ws: WebSocket, message: WSMessage): Promise<void> {\n    // Handle keep-alive pings first (internal waitUntil mechanism)\n    const tags = this.ctx.getTags(ws);\n    if (tags.includes(\"partyserver-keepalive\")) {\n      if (message === \"ping\") {\n        ws.send(\"pong\");\n      }\n      return;\n    }\n\n    // Ignore websockets accepted outside PartyServer (e.g. via\n    // `state.acceptWebSocket()` in user code). These sockets won't have the\n    // `__pk` attachment namespace required to rehydrate a Connection.\n    if (!isPartyServerWebSocket(ws)) {\n      return;\n    }\n\n    const connection = createLazyConnection(ws);\n\n    // rehydrate the server name if it's woken up\n    await this.setName(connection.server);\n    // TODO: ^ this shouldn't be async\n\n    if (this.#status !== \"started\") {\n      // This means the server \"woke up\" after hibernation\n      // so we need to hydrate it again\n      await this.#initialize();\n    }\n\n    return this.onMessage(connection, message);\n  }\n\n  async webSocketClose(\n    ws: WebSocket,\n    code: number,\n    reason: string,\n    wasClean: boolean\n  ): Promise<void> {\n    // Ignore keep-alive socket closes (internal waitUntil mechanism)\n    const tags = this.ctx.getTags(ws);\n    if (tags.includes(\"partyserver-keepalive\")) {\n      return;\n    }\n\n    if (!isPartyServerWebSocket(ws)) {\n      return;\n    }\n\n    const connection = createLazyConnection(ws);\n\n    // rehydrate the server name if it's woken up\n    await this.setName(connection.server);\n    // TODO: ^ this shouldn't be async\n\n    if (this.#status !== \"started\") {\n      // This means the server \"woke up\" after hibernation\n      // so we need to hydrate it again\n      await this.#initialize();\n    }\n    return this.onClose(connection, code, reason, wasClean);\n  }\n\n  async webSocketError(ws: WebSocket, error: unknown): Promise<void> {\n    // Ignore keep-alive socket errors (internal waitUntil mechanism)\n    const tags = this.ctx.getTags(ws);\n    if (tags.includes(\"partyserver-keepalive\")) {\n      return;\n    }\n\n    if (!isPartyServerWebSocket(ws)) {\n      return;\n    }\n\n    const connection = createLazyConnection(ws);\n\n    // rehydrate the server name if it's woken up\n    await this.setName(connection.server);\n    // TODO: ^ this shouldn't be async\n\n    if (this.#status !== \"started\") {\n      // This means the server \"woke up\" after hibernation\n      // so we need to hydrate it again\n      await this.#initialize();\n    }\n    return this.onError(connection, error);\n  }\n\n  async #initialize(): Promise<void> {\n    await this.ctx.blockConcurrencyWhile(async () => {\n      this.#status = \"starting\";\n      await this.onStart(this.#_props);\n      this.#status = \"started\";\n    });\n  }\n\n  #attachSocketEventHandlers(connection: Connection) {\n    const handleMessageFromClient = (event: MessageEvent) => {\n      this.onMessage(connection, event.data)?.catch<void>((e) => {\n        console.error(\"onMessage error:\", e);\n      });\n    };\n\n    const handleCloseFromClient = (event: CloseEvent) => {\n      connection.removeEventListener(\"message\", handleMessageFromClient);\n      connection.removeEventListener(\"close\", handleCloseFromClient);\n      this.onClose(connection, event.code, event.reason, event.wasClean)?.catch(\n        (e) => {\n          console.error(\"onClose error:\", e);\n        }\n      );\n    };\n\n    const handleErrorFromClient = (e: ErrorEvent) => {\n      connection.removeEventListener(\"message\", handleMessageFromClient);\n      connection.removeEventListener(\"error\", handleErrorFromClient);\n      this.onError(connection, e.error)?.catch((e) => {\n        console.error(\"onError error:\", e);\n      });\n    };\n\n    connection.addEventListener(\"close\", handleCloseFromClient);\n    connection.addEventListener(\"error\", handleErrorFromClient);\n    connection.addEventListener(\"message\", handleMessageFromClient);\n  }\n\n  // Public API\n\n  #_name: string | undefined;\n\n  #_longErrorAboutNameThrown = false;\n  /**\n   * The name for this server. Write-once-only.\n   */\n  get name(): string {\n    if (!this.#_name) {\n      if (!this.#_longErrorAboutNameThrown) {\n        this.#_longErrorAboutNameThrown = true;\n        throw new Error(\n          `Attempting to read .name on ${this.#ParentClass.name} before it was set. The name can be set by explicitly calling .setName(name) on the stub, or by using routePartyKitRequest(). This is a known issue and will be fixed soon. Follow https://github.com/cloudflare/workerd/issues/2240 for more updates.`\n        );\n      } else {\n        throw new Error(\n          `Attempting to read .name on ${this.#ParentClass.name} before it was set.`\n        );\n      }\n    }\n    return this.#_name;\n  }\n\n  // We won't have an await inside this function\n  // but it will be called remotely,\n  // so we need to mark it as async\n  async setName(name: string) {\n    if (!name) {\n      throw new Error(\"A name is required.\");\n    }\n    if (this.#_name && this.#_name !== name) {\n      throw new Error(\n        `This server already has a name: ${this.#_name}, attempting to set to: ${name}`\n      );\n    }\n    this.#_name = name;\n\n    if (this.#status !== \"started\") {\n      await this.ctx.blockConcurrencyWhile(async () => {\n        await this.#initialize();\n      });\n    }\n  }\n\n  #sendMessageToConnection(connection: Connection, message: WSMessage): void {\n    try {\n      connection.send(message);\n    } catch (_e) {\n      // close connection\n      connection.close(1011, \"Unexpected error\");\n    }\n  }\n\n  /** Send a message to all connected clients, except connection ids listed in `without` */\n  broadcast(\n    msg: string | ArrayBuffer | ArrayBufferView,\n    without?: string[] | undefined\n  ): void {\n    for (const connection of this.#connectionManager.getConnections()) {\n      if (!without || !without.includes(connection.id)) {\n        this.#sendMessageToConnection(connection, msg);\n      }\n    }\n  }\n\n  /** Get a connection by connection id */\n  getConnection<TState = unknown>(id: string): Connection<TState> | undefined {\n    return this.#connectionManager.getConnection<TState>(id);\n  }\n\n  /**\n   * Get all connections. Optionally, you can provide a tag to filter returned connections.\n   * Use `Server#getConnectionTags` to tag the connection on connect.\n   */\n  getConnections<TState = unknown>(tag?: string): Iterable<Connection<TState>> {\n    return this.#connectionManager.getConnections<TState>(tag);\n  }\n\n  /**\n   * You can tag a connection to filter them in Server#getConnections.\n   * Each connection supports up to 9 tags, each tag max length is 256 characters.\n   */\n  getConnectionTags(\n    // biome-ignore lint/correctness/noUnusedFunctionParameters: for autocomplete\n    connection: Connection,\n    // biome-ignore lint/correctness/noUnusedFunctionParameters: for autocomplete\n    context: ConnectionContext\n  ): string[] | Promise<string[]> {\n    return [];\n  }\n\n  /**\n   * Execute a long-running async function while keeping the Durable Object alive.\n   *\n   * Durable Objects normally terminate 70-140s after the last network request.\n   * This method keeps the DO alive by establishing a WebSocket connection to itself\n   * and sending periodic ping messages.\n   *\n   * @experimental This API is experimental and may change in future versions.\n   *\n   * @param fn - The async function to execute\n   * @param timeoutMs - Maximum time to keep the DO alive (default: 30 minutes)\n   * @returns The result of the async function\n   *\n   * @remarks\n   * Requires the `enable_ctx_exports` compatibility flag in wrangler.jsonc:\n   * ```json\n   * {\n   *   \"compatibility_flags\": [\"enable_ctx_exports\"]\n   * }\n   * ```\n   *\n   * @example\n   * ```typescript\n   * const result = await this.experimental_waitUntil(async () => {\n   *   // Long-running operation\n   *   await processLargeDataset();\n   *   return { success: true };\n   * }, 60 * 60 * 1000); // 1 hour timeout\n   * ```\n   */\n  async experimental_waitUntil<T>(\n    fn: () => Promise<T>,\n    timeoutMs: number = 30 * 60 * 1000 // 30 minutes default\n  ): Promise<T> {\n    // Get namespace from ctx.exports (requires enable_ctx_exports compatibility flag)\n    const exports = (\n      this.ctx as DurableObjectState & { exports?: Record<string, unknown> }\n    ).exports;\n    if (!exports) {\n      throw new Error(\n        \"waitUntil requires the 'enable_ctx_exports' compatibility flag. \" +\n          'Add it to your wrangler.jsonc: { \"compatibility_flags\": [\"enable_ctx_exports\"] }'\n      );\n    }\n\n    const namespace = exports[this.#ParentClass.name] as\n      | DurableObjectNamespace\n      | undefined;\n    if (!namespace) {\n      throw new Error(\n        `Could not find namespace for ${this.#ParentClass.name} in ctx.exports. ` +\n          \"Make sure the class name matches your Durable Object binding.\"\n      );\n    }\n\n    const stub = namespace.get(this.ctx.id);\n\n    // Connect to self via WebSocket for keep-alive\n    const response = await stub.fetch(\n      \"http://dummy-example.cloudflare.com/cdn-cgi/partyserver/keep-alive/\",\n      {\n        headers: {\n          Upgrade: \"websocket\",\n          \"x-partykit-room\": this.name\n        }\n      }\n    );\n\n    const ws = response.webSocket;\n    if (!ws) {\n      throw new Error(\"Failed to establish keep-alive WebSocket connection\");\n    }\n    ws.accept();\n\n    // Set up ping interval (every 10 seconds)\n    const pingInterval = setInterval(() => {\n      try {\n        ws.send(\"ping\");\n      } catch {\n        // WebSocket may have closed, ignore\n      }\n    }, 10_000);\n\n    // Create a timeout promise that rejects after timeoutMs\n    let timeoutId: ReturnType<typeof setTimeout>;\n    const timeoutPromise = new Promise<never>((_, reject) => {\n      timeoutId = setTimeout(() => {\n        reject(\n          new Error(`experimental_waitUntil timed out after ${timeoutMs}ms`)\n        );\n      }, timeoutMs);\n    });\n\n    try {\n      // Race the function against the timeout\n      const result = await Promise.race([fn(), timeoutPromise]);\n      return result;\n    } finally {\n      clearTimeout(timeoutId!);\n      clearInterval(pingInterval);\n      try {\n        ws.close(1000, \"Complete\");\n      } catch {\n        // Ignore close errors\n      }\n    }\n  }\n\n  #_props?: Props;\n\n  // Implemented by the user\n\n  /**\n   * Called when the server is started for the first time.\n   */\n  // biome-ignore lint/correctness/noUnusedFunctionParameters: for autocomplete\n  onStart(props?: Props): void | Promise<void> {}\n\n  /**\n   * Called when a new connection is made to the server.\n   */\n  onConnect(\n    connection: Connection,\n    // biome-ignore lint/correctness/noUnusedFunctionParameters: for autocomplete\n    ctx: ConnectionContext\n  ): void | Promise<void> {\n    console.log(\n      `Connection ${connection.id} connected to ${this.#ParentClass.name}:${this.name}`\n    );\n    // console.log(\n    //   `Implement onConnect on ${this.#ParentClass.name} to handle websocket connections.`\n    // );\n  }\n\n  /**\n   * Called when a message is received from a connection.\n   */\n  // biome-ignore lint/correctness/noUnusedFunctionParameters: for autocomplete\n  onMessage(connection: Connection, message: WSMessage): void | Promise<void> {\n    console.log(\n      `Received message on connection ${this.#ParentClass.name}:${connection.id}`\n    );\n    console.info(\n      `Implement onMessage on ${this.#ParentClass.name} to handle this message.`\n    );\n  }\n\n  /**\n   * Called when a connection is closed.\n   */\n  onClose(\n    // biome-ignore lint/correctness/noUnusedFunctionParameters: for autocomplete\n    connection: Connection,\n    // biome-ignore lint/correctness/noUnusedFunctionParameters: for autocomplete\n    code: number,\n    // biome-ignore lint/correctness/noUnusedFunctionParameters: for autocomplete\n    reason: string,\n    // biome-ignore lint/correctness/noUnusedFunctionParameters: for autocomplete\n    wasClean: boolean\n  ): void | Promise<void> {}\n\n  /**\n   * Called when an error occurs on a connection.\n   */\n  onError(connection: Connection, error: unknown): void | Promise<void> {\n    console.error(\n      `Error on connection ${connection.id} in ${this.#ParentClass.name}:${this.name}:`,\n      error\n    );\n    console.info(\n      `Implement onError on ${this.#ParentClass.name} to handle this error.`\n    );\n  }\n\n  /**\n   * Called when a request is made to the server.\n   */\n  onRequest(request: Request): Response | Promise<Response> {\n    // default to 404\n\n    console.warn(\n      `onRequest hasn't been implemented on ${this.#ParentClass.name}:${this.name} responding to ${request.url}`\n    );\n\n    return new Response(\"Not implemented\", { status: 404 });\n  }\n\n  /**\n   * Called when an exception occurs.\n   * @param error - The error that occurred.\n   */\n  onException(error: unknown): void | Promise<void> {\n    console.error(\n      `Exception in ${this.#ParentClass.name}:${this.name}:`,\n      error\n    );\n    console.info(\n      `Implement onException on ${this.#ParentClass.name} to handle this error.`\n    );\n  }\n\n  onAlarm(): void | Promise<void> {\n    console.log(\n      `Implement onAlarm on ${this.#ParentClass.name} to handle alarms.`\n    );\n  }\n\n  async alarm(): Promise<void> {\n    if (this.#status !== \"started\") {\n      // This means the server \"woke up\" after hibernation\n      // so we need to hydrate it again\n      await this.#initialize();\n    }\n    await this.onAlarm();\n  }\n}\n"],"mappings":"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"}