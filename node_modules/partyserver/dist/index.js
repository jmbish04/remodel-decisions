import { DurableObject, env } from "cloudflare:workers";
import { nanoid } from "nanoid";

//#region src/connection.ts
if (!("OPEN" in WebSocket)) {
	const WebSocketStatus = {
		CONNECTING: WebSocket.READY_STATE_CONNECTING,
		OPEN: WebSocket.READY_STATE_OPEN,
		CLOSING: WebSocket.READY_STATE_CLOSING,
		CLOSED: WebSocket.READY_STATE_CLOSED
	};
	Object.assign(WebSocket, WebSocketStatus);
	Object.assign(WebSocket.prototype, WebSocketStatus);
}
function tryGetPartyServerMeta(ws) {
	try {
		const attachment = WebSocket.prototype.deserializeAttachment.call(ws);
		if (!attachment || typeof attachment !== "object") return null;
		if (!("__pk" in attachment)) return null;
		const pk = attachment.__pk;
		if (!pk || typeof pk !== "object") return null;
		const { id, server } = pk;
		if (typeof id !== "string" || typeof server !== "string") return null;
		return pk;
	} catch {
		return null;
	}
}
function isPartyServerWebSocket(ws) {
	return tryGetPartyServerMeta(ws) !== null;
}
/**
* Cache websocket attachments to avoid having to rehydrate them on every property access.
*/
var AttachmentCache = class {
	#cache = /* @__PURE__ */ new WeakMap();
	get(ws) {
		let attachment = this.#cache.get(ws);
		if (!attachment) {
			attachment = WebSocket.prototype.deserializeAttachment.call(ws);
			if (attachment !== void 0) this.#cache.set(ws, attachment);
			else throw new Error("Missing websocket attachment. This is most likely an issue in PartyServer, please open an issue at https://github.com/cloudflare/partykit/issues");
		}
		return attachment;
	}
	set(ws, attachment) {
		this.#cache.set(ws, attachment);
		WebSocket.prototype.serializeAttachment.call(ws, attachment);
	}
};
const attachments = new AttachmentCache();
const connections = /* @__PURE__ */ new WeakSet();
const isWrapped = (ws) => {
	return connections.has(ws);
};
/**
* Wraps a WebSocket with Connection fields that rehydrate the
* socket attachments lazily only when requested.
*/
const createLazyConnection = (ws) => {
	if (isWrapped(ws)) return ws;
	let initialState;
	if ("state" in ws) {
		initialState = ws.state;
		delete ws.state;
	}
	const connection = Object.defineProperties(ws, {
		id: { get() {
			return attachments.get(ws).__pk.id;
		} },
		server: { get() {
			return attachments.get(ws).__pk.server;
		} },
		socket: { get() {
			return ws;
		} },
		state: { get() {
			return ws.deserializeAttachment();
		} },
		setState: { value: function setState(setState$1) {
			let state;
			if (setState$1 instanceof Function) state = setState$1(this.state);
			else state = setState$1;
			ws.serializeAttachment(state);
			return state;
		} },
		deserializeAttachment: { value: function deserializeAttachment() {
			return attachments.get(ws).__user ?? null;
		} },
		serializeAttachment: { value: function serializeAttachment(attachment) {
			const setting = {
				...attachments.get(ws),
				__user: attachment ?? null
			};
			attachments.set(ws, setting);
		} }
	});
	if (initialState) connection.setState(initialState);
	connections.add(connection);
	return connection;
};
var HibernatingConnectionIterator = class {
	index = 0;
	sockets;
	constructor(state, tag) {
		this.state = state;
		this.tag = tag;
	}
	[Symbol.iterator]() {
		return this;
	}
	next() {
		const sockets = this.sockets ?? (this.sockets = this.state.getWebSockets(this.tag));
		let socket;
		while (socket = sockets[this.index++]) if (socket.readyState === WebSocket.READY_STATE_OPEN) {
			if (!isPartyServerWebSocket(socket)) continue;
			return {
				done: false,
				value: createLazyConnection(socket)
			};
		}
		return {
			done: true,
			value: void 0
		};
	}
};
/**
* When not using hibernation, we track active connections manually.
*/
var InMemoryConnectionManager = class {
	#connections = /* @__PURE__ */ new Map();
	tags = /* @__PURE__ */ new WeakMap();
	getCount() {
		return this.#connections.size;
	}
	getConnection(id) {
		return this.#connections.get(id);
	}
	*getConnections(tag) {
		if (!tag) {
			yield* this.#connections.values().filter((c) => c.readyState === WebSocket.READY_STATE_OPEN);
			return;
		}
		for (const connection of this.#connections.values()) if ((this.tags.get(connection) ?? []).includes(tag)) yield connection;
	}
	accept(connection, options) {
		connection.accept();
		this.#connections.set(connection.id, connection);
		this.tags.set(connection, [connection.id, ...options.tags.filter((t) => t !== connection.id)]);
		const removeConnection = () => {
			this.#connections.delete(connection.id);
			connection.removeEventListener("close", removeConnection);
			connection.removeEventListener("error", removeConnection);
		};
		connection.addEventListener("close", removeConnection);
		connection.addEventListener("error", removeConnection);
		return connection;
	}
};
/**
* When opting into hibernation, the platform tracks connections for us.
*/
var HibernatingConnectionManager = class {
	constructor(controller) {
		this.controller = controller;
	}
	getCount() {
		let count = 0;
		for (const ws of this.controller.getWebSockets()) if (isPartyServerWebSocket(ws)) count++;
		return count;
	}
	getConnection(id) {
		const matching = this.controller.getWebSockets(id).filter((ws) => {
			return tryGetPartyServerMeta(ws)?.id === id;
		});
		if (matching.length === 0) return void 0;
		if (matching.length === 1) return createLazyConnection(matching[0]);
		throw new Error(`More than one connection found for id ${id}. Did you mean to use getConnections(tag) instead?`);
	}
	getConnections(tag) {
		return new HibernatingConnectionIterator(this.controller, tag);
	}
	accept(connection, options) {
		const tags = [connection.id, ...options.tags.filter((t) => t !== connection.id)];
		if (tags.length > 10) throw new Error("A connection can only have 10 tags, including the default id tag.");
		for (const tag of tags) {
			if (typeof tag !== "string") throw new Error(`A connection tag must be a string. Received: ${tag}`);
			if (tag === "") throw new Error("A connection tag must not be an empty string.");
			if (tag.length > 256) throw new Error("A connection tag must not exceed 256 characters");
		}
		this.controller.acceptWebSocket(connection, tags);
		connection.serializeAttachment({
			__pk: {
				id: connection.id,
				server: options.server
			},
			__user: null
		});
		return createLazyConnection(connection);
	}
};

//#endregion
//#region src/index.ts
const serverMapCache = /* @__PURE__ */ new WeakMap();
/**
* For a given server namespace, create a server with a name.
*/
async function getServerByName(serverNamespace, name, options) {
	if (options?.jurisdiction) serverNamespace = serverNamespace.jurisdiction(options.jurisdiction);
	const id = serverNamespace.idFromName(name);
	const stub = serverNamespace.get(id, options);
	const req = new Request("http://dummy-example.cloudflare.com/cdn-cgi/partyserver/set-name/");
	req.headers.set("x-partykit-room", name);
	if (options?.props) req.headers.set("x-partykit-props", JSON.stringify(options?.props));
	await stub.fetch(req).then((res) => res.text()).catch((e) => {
		console.error("Could not set server name:", e);
	});
	return stub;
}
function camelCaseToKebabCase(str) {
	if (str === str.toUpperCase() && str !== str.toLowerCase()) return str.toLowerCase().replace(/_/g, "-");
	let kebabified = str.replace(/[A-Z]/g, (letter) => `-${letter.toLowerCase()}`);
	kebabified = kebabified.startsWith("-") ? kebabified.slice(1) : kebabified;
	return kebabified.replace(/_/g, "-").replace(/-$/, "");
}
/**
* A utility function for PartyKit style routing.
*/
async function routePartykitRequest(req, env$1 = env, options) {
	if (!serverMapCache.has(env$1)) serverMapCache.set(env$1, Object.entries(env$1).reduce((acc, [k, v]) => {
		if (v && typeof v === "object" && "idFromName" in v && typeof v.idFromName === "function") {
			Object.assign(acc, { [camelCaseToKebabCase(k)]: v });
			return acc;
		}
		return acc;
	}, {}));
	const map = serverMapCache.get(env$1);
	const prefixParts = (options?.prefix || "parties").split("/");
	const parts = new URL(req.url).pathname.split("/").filter(Boolean);
	if (!prefixParts.every((part, index) => parts[index] === part) || parts.length < prefixParts.length + 2) return null;
	const namespace = parts[prefixParts.length];
	const name = parts[prefixParts.length + 1];
	if (name && namespace) {
		if (!map[namespace]) {
			if (namespace === "main") {
				console.warn("You appear to be migrating a PartyKit project to PartyServer.");
				console.warn(`PartyServer doesn't have a "main" party by default. Try adding this to your PartySocket client:\n 
party: "${camelCaseToKebabCase(Object.keys(map)[0])}"`);
			} else console.error(`The url ${req.url}  with namespace "${namespace}" and name "${name}" does not match any server namespace. 
Did you forget to add a durable object binding to the class ${namespace[0].toUpperCase() + namespace.slice(1)} in your wrangler.jsonc?`);
			return new Response("Invalid request", { status: 400 });
		}
		let doNamespace = map[namespace];
		if (options?.jurisdiction) doNamespace = doNamespace.jurisdiction(options.jurisdiction);
		const id = doNamespace.idFromName(name);
		const stub = doNamespace.get(id, options);
		req = new Request(req);
		req.headers.set("x-partykit-room", name);
		req.headers.set("x-partykit-namespace", namespace);
		if (options?.jurisdiction) req.headers.set("x-partykit-jurisdiction", options.jurisdiction);
		if (options?.props) req.headers.set("x-partykit-props", JSON.stringify(options?.props));
		if (req.headers.get("Upgrade")?.toLowerCase() === "websocket") {
			if (options?.onBeforeConnect) {
				const reqOrRes = await options.onBeforeConnect(req, {
					party: namespace,
					name
				});
				if (reqOrRes instanceof Request) req = reqOrRes;
				else if (reqOrRes instanceof Response) return reqOrRes;
			}
		} else if (options?.onBeforeRequest) {
			const reqOrRes = await options.onBeforeRequest(req, {
				party: namespace,
				name
			});
			if (reqOrRes instanceof Request) req = reqOrRes;
			else if (reqOrRes instanceof Response) return reqOrRes;
		}
		return stub.fetch(req);
	} else return null;
}
var Server = class extends DurableObject {
	static options = { hibernate: false };
	#status = "zero";
	#ParentClass = Object.getPrototypeOf(this).constructor;
	#connectionManager = this.#ParentClass.options.hibernate ? new HibernatingConnectionManager(this.ctx) : new InMemoryConnectionManager();
	/**
	* Execute SQL queries against the Server's database
	* @template T Type of the returned rows
	* @param strings SQL query template strings
	* @param values Values to be inserted into the query
	* @returns Array of query results
	*/
	sql(strings, ...values) {
		let query = "";
		try {
			query = strings.reduce((acc, str, i) => acc + str + (i < values.length ? "?" : ""), "");
			return [...this.ctx.storage.sql.exec(query, ...values)];
		} catch (e) {
			console.error(`failed to execute sql query: ${query}`, e);
			throw this.onException(e);
		}
	}
	constructor(ctx, env$1) {
		super(ctx, env$1);
	}
	/**
	* Handle incoming requests to the server.
	*/
	async fetch(request) {
		const props = request.headers.get("x-partykit-props");
		if (props) try {
			this.#_props = JSON.parse(props);
		} catch {
			console.error("Internal error parsing context props.");
		}
		if (!this.#_name) {
			const room = request.headers.get("x-partykit-room");
			if (!room) throw new Error(`Missing namespace or room headers when connecting to ${this.#ParentClass.name}.
Did you try connecting directly to this Durable Object? Try using getServerByName(namespace, id) instead.`);
			await this.setName(room);
		}
		try {
			const url = new URL(request.url);
			if (url.pathname === "/cdn-cgi/partyserver/set-name/") return Response.json({ ok: true });
			if (url.pathname === "/cdn-cgi/partyserver/keep-alive/") {
				if (request.headers.get("Upgrade")?.toLowerCase() === "websocket") {
					const { 0: client, 1: server } = new WebSocketPair();
					this.ctx.acceptWebSocket(server, ["partyserver-keepalive"]);
					return new Response(null, {
						status: 101,
						webSocket: client
					});
				}
				return new Response("WebSocket required", { status: 426 });
			}
			if (request.headers.get("Upgrade")?.toLowerCase() !== "websocket") return await this.onRequest(request);
			else {
				const { 0: clientWebSocket, 1: serverWebSocket } = new WebSocketPair();
				let connectionId = url.searchParams.get("_pk");
				if (!connectionId) connectionId = nanoid();
				let connection = Object.assign(serverWebSocket, {
					id: connectionId,
					server: this.name,
					state: null,
					setState(setState) {
						let state;
						if (setState instanceof Function) state = setState(this.state);
						else state = setState;
						this.state = state;
						return this.state;
					}
				});
				const ctx = { request };
				const tags = await this.getConnectionTags(connection, ctx);
				connection = this.#connectionManager.accept(connection, {
					tags,
					server: this.name
				});
				if (!this.#ParentClass.options.hibernate) this.#attachSocketEventHandlers(connection);
				await this.onConnect(connection, ctx);
				return new Response(null, {
					status: 101,
					webSocket: clientWebSocket
				});
			}
		} catch (err) {
			console.error(`Error in ${this.#ParentClass.name}:${this.name} fetch:`, err);
			if (!(err instanceof Error)) throw err;
			if (request.headers.get("Upgrade") === "websocket") {
				const pair = new WebSocketPair();
				pair[1].accept();
				pair[1].send(JSON.stringify({ error: err.stack }));
				pair[1].close(1011, "Uncaught exception during session setup");
				return new Response(null, {
					status: 101,
					webSocket: pair[0]
				});
			} else return new Response(err.stack, { status: 500 });
		}
	}
	async webSocketMessage(ws, message) {
		if (this.ctx.getTags(ws).includes("partyserver-keepalive")) {
			if (message === "ping") ws.send("pong");
			return;
		}
		if (!isPartyServerWebSocket(ws)) return;
		const connection = createLazyConnection(ws);
		await this.setName(connection.server);
		if (this.#status !== "started") await this.#initialize();
		return this.onMessage(connection, message);
	}
	async webSocketClose(ws, code, reason, wasClean) {
		if (this.ctx.getTags(ws).includes("partyserver-keepalive")) return;
		if (!isPartyServerWebSocket(ws)) return;
		const connection = createLazyConnection(ws);
		await this.setName(connection.server);
		if (this.#status !== "started") await this.#initialize();
		return this.onClose(connection, code, reason, wasClean);
	}
	async webSocketError(ws, error) {
		if (this.ctx.getTags(ws).includes("partyserver-keepalive")) return;
		if (!isPartyServerWebSocket(ws)) return;
		const connection = createLazyConnection(ws);
		await this.setName(connection.server);
		if (this.#status !== "started") await this.#initialize();
		return this.onError(connection, error);
	}
	async #initialize() {
		await this.ctx.blockConcurrencyWhile(async () => {
			this.#status = "starting";
			await this.onStart(this.#_props);
			this.#status = "started";
		});
	}
	#attachSocketEventHandlers(connection) {
		const handleMessageFromClient = (event) => {
			this.onMessage(connection, event.data)?.catch((e) => {
				console.error("onMessage error:", e);
			});
		};
		const handleCloseFromClient = (event) => {
			connection.removeEventListener("message", handleMessageFromClient);
			connection.removeEventListener("close", handleCloseFromClient);
			this.onClose(connection, event.code, event.reason, event.wasClean)?.catch((e) => {
				console.error("onClose error:", e);
			});
		};
		const handleErrorFromClient = (e) => {
			connection.removeEventListener("message", handleMessageFromClient);
			connection.removeEventListener("error", handleErrorFromClient);
			this.onError(connection, e.error)?.catch((e$1) => {
				console.error("onError error:", e$1);
			});
		};
		connection.addEventListener("close", handleCloseFromClient);
		connection.addEventListener("error", handleErrorFromClient);
		connection.addEventListener("message", handleMessageFromClient);
	}
	#_name;
	#_longErrorAboutNameThrown = false;
	/**
	* The name for this server. Write-once-only.
	*/
	get name() {
		if (!this.#_name) if (!this.#_longErrorAboutNameThrown) {
			this.#_longErrorAboutNameThrown = true;
			throw new Error(`Attempting to read .name on ${this.#ParentClass.name} before it was set. The name can be set by explicitly calling .setName(name) on the stub, or by using routePartyKitRequest(). This is a known issue and will be fixed soon. Follow https://github.com/cloudflare/workerd/issues/2240 for more updates.`);
		} else throw new Error(`Attempting to read .name on ${this.#ParentClass.name} before it was set.`);
		return this.#_name;
	}
	async setName(name) {
		if (!name) throw new Error("A name is required.");
		if (this.#_name && this.#_name !== name) throw new Error(`This server already has a name: ${this.#_name}, attempting to set to: ${name}`);
		this.#_name = name;
		if (this.#status !== "started") await this.ctx.blockConcurrencyWhile(async () => {
			await this.#initialize();
		});
	}
	#sendMessageToConnection(connection, message) {
		try {
			connection.send(message);
		} catch (_e) {
			connection.close(1011, "Unexpected error");
		}
	}
	/** Send a message to all connected clients, except connection ids listed in `without` */
	broadcast(msg, without) {
		for (const connection of this.#connectionManager.getConnections()) if (!without || !without.includes(connection.id)) this.#sendMessageToConnection(connection, msg);
	}
	/** Get a connection by connection id */
	getConnection(id) {
		return this.#connectionManager.getConnection(id);
	}
	/**
	* Get all connections. Optionally, you can provide a tag to filter returned connections.
	* Use `Server#getConnectionTags` to tag the connection on connect.
	*/
	getConnections(tag) {
		return this.#connectionManager.getConnections(tag);
	}
	/**
	* You can tag a connection to filter them in Server#getConnections.
	* Each connection supports up to 9 tags, each tag max length is 256 characters.
	*/
	getConnectionTags(connection, context) {
		return [];
	}
	/**
	* Execute a long-running async function while keeping the Durable Object alive.
	*
	* Durable Objects normally terminate 70-140s after the last network request.
	* This method keeps the DO alive by establishing a WebSocket connection to itself
	* and sending periodic ping messages.
	*
	* @experimental This API is experimental and may change in future versions.
	*
	* @param fn - The async function to execute
	* @param timeoutMs - Maximum time to keep the DO alive (default: 30 minutes)
	* @returns The result of the async function
	*
	* @remarks
	* Requires the `enable_ctx_exports` compatibility flag in wrangler.jsonc:
	* ```json
	* {
	*   "compatibility_flags": ["enable_ctx_exports"]
	* }
	* ```
	*
	* @example
	* ```typescript
	* const result = await this.experimental_waitUntil(async () => {
	*   // Long-running operation
	*   await processLargeDataset();
	*   return { success: true };
	* }, 60 * 60 * 1000); // 1 hour timeout
	* ```
	*/
	async experimental_waitUntil(fn, timeoutMs = 1800 * 1e3) {
		const exports = this.ctx.exports;
		if (!exports) throw new Error("waitUntil requires the 'enable_ctx_exports' compatibility flag. Add it to your wrangler.jsonc: { \"compatibility_flags\": [\"enable_ctx_exports\"] }");
		const namespace = exports[this.#ParentClass.name];
		if (!namespace) throw new Error(`Could not find namespace for ${this.#ParentClass.name} in ctx.exports. Make sure the class name matches your Durable Object binding.`);
		const ws = (await namespace.get(this.ctx.id).fetch("http://dummy-example.cloudflare.com/cdn-cgi/partyserver/keep-alive/", { headers: {
			Upgrade: "websocket",
			"x-partykit-room": this.name
		} })).webSocket;
		if (!ws) throw new Error("Failed to establish keep-alive WebSocket connection");
		ws.accept();
		const pingInterval = setInterval(() => {
			try {
				ws.send("ping");
			} catch {}
		}, 1e4);
		let timeoutId;
		const timeoutPromise = new Promise((_, reject) => {
			timeoutId = setTimeout(() => {
				reject(/* @__PURE__ */ new Error(`experimental_waitUntil timed out after ${timeoutMs}ms`));
			}, timeoutMs);
		});
		try {
			return await Promise.race([fn(), timeoutPromise]);
		} finally {
			clearTimeout(timeoutId);
			clearInterval(pingInterval);
			try {
				ws.close(1e3, "Complete");
			} catch {}
		}
	}
	#_props;
	/**
	* Called when the server is started for the first time.
	*/
	onStart(props) {}
	/**
	* Called when a new connection is made to the server.
	*/
	onConnect(connection, ctx) {
		console.log(`Connection ${connection.id} connected to ${this.#ParentClass.name}:${this.name}`);
	}
	/**
	* Called when a message is received from a connection.
	*/
	onMessage(connection, message) {
		console.log(`Received message on connection ${this.#ParentClass.name}:${connection.id}`);
		console.info(`Implement onMessage on ${this.#ParentClass.name} to handle this message.`);
	}
	/**
	* Called when a connection is closed.
	*/
	onClose(connection, code, reason, wasClean) {}
	/**
	* Called when an error occurs on a connection.
	*/
	onError(connection, error) {
		console.error(`Error on connection ${connection.id} in ${this.#ParentClass.name}:${this.name}:`, error);
		console.info(`Implement onError on ${this.#ParentClass.name} to handle this error.`);
	}
	/**
	* Called when a request is made to the server.
	*/
	onRequest(request) {
		console.warn(`onRequest hasn't been implemented on ${this.#ParentClass.name}:${this.name} responding to ${request.url}`);
		return new Response("Not implemented", { status: 404 });
	}
	/**
	* Called when an exception occurs.
	* @param error - The error that occurred.
	*/
	onException(error) {
		console.error(`Exception in ${this.#ParentClass.name}:${this.name}:`, error);
		console.info(`Implement onException on ${this.#ParentClass.name} to handle this error.`);
	}
	onAlarm() {
		console.log(`Implement onAlarm on ${this.#ParentClass.name} to handle alarms.`);
	}
	async alarm() {
		if (this.#status !== "started") await this.#initialize();
		await this.onAlarm();
	}
};

//#endregion
export { Server, getServerByName, routePartykitRequest };
//# sourceMappingURL=index.js.map