import { DurableObject } from "cloudflare:workers";

//#region src/types.d.ts
type ImmutablePrimitive = undefined | null | boolean | string | number;
type Immutable<T> = T extends ImmutablePrimitive
  ? T
  : T extends Array<infer U>
    ? ImmutableArray<U>
    : T extends Map<infer K, infer V>
      ? ImmutableMap<K, V>
      : T extends Set<infer M>
        ? ImmutableSet<M>
        : ImmutableObject<T>;
type ImmutableArray<T> = ReadonlyArray<Immutable<T>>;
type ImmutableMap<K$1, V$1> = ReadonlyMap<Immutable<K$1>, Immutable<V$1>>;
type ImmutableSet<T> = ReadonlySet<Immutable<T>>;
type ImmutableObject<T> = { readonly [K in keyof T]: Immutable<T[K]> };
type ConnectionState<T> = ImmutableObject<T> | null;
type ConnectionSetStateFn<T> = (prevState: ConnectionState<T>) => T;
type ConnectionContext = {
  request: Request;
};
/** A WebSocket connected to the Server */
type Connection<TState = unknown> = WebSocket & {
  /** Connection identifier */
  id: string;
  /**
   * Arbitrary state associated with this connection.
   * Read-only, use Connection.setState to update the state.
   */
  state: ConnectionState<TState>;
  setState(
    state: TState | ConnectionSetStateFn<TState> | null
  ): ConnectionState<TState>;
  /** @deprecated use Connection.setState instead */
  serializeAttachment<T = unknown>(attachment: T): void;
  /** @deprecated use Connection.state instead */
  deserializeAttachment<T = unknown>(): T | null;
  /**
   * Server's name
   */
  server: string;
};
//#endregion
//#region src/index.d.ts
type WSMessage = ArrayBuffer | ArrayBufferView | string;
/**
 * For a given server namespace, create a server with a name.
 */
declare function getServerByName<
  Env extends Cloudflare.Env = Cloudflare.Env,
  T extends Server<Env> = Server<Env>,
  Props extends Record<string, unknown> = Record<string, unknown>
>(
  serverNamespace: DurableObjectNamespace<T>,
  name: string,
  options?: {
    jurisdiction?: DurableObjectJurisdiction;
    locationHint?: DurableObjectLocationHint;
    props?: Props;
  }
): Promise<DurableObjectStub<T>>;
interface PartyServerOptions<
  Env = Cloudflare.Env,
  Props = Record<string, unknown>
> {
  prefix?: string;
  jurisdiction?: DurableObjectJurisdiction;
  locationHint?: DurableObjectLocationHint;
  props?: Props;
  onBeforeConnect?: (
    req: Request,
    lobby: {
      party: string;
      name: string;
    }
  ) => Response | Request | void | Promise<Response | Request | void>;
  onBeforeRequest?: (
    req: Request,
    lobby: {
      party: string;
      name: string;
    }
  ) =>
    | Response
    | Request
    | void
    | Promise<Response | Request | undefined | void>;
}
/**
 * A utility function for PartyKit style routing.
 */
declare function routePartykitRequest<
  Env extends Cloudflare.Env = Cloudflare.Env,
  T extends Server<Env> = Server<Env>,
  Props extends Record<string, unknown> = Record<string, unknown>
>(
  req: Request,
  env?: Env,
  options?: PartyServerOptions<Env, Props>
): Promise<Response | null>;
declare class Server<
  Env extends Cloudflare.Env = Cloudflare.Env,
  Props extends Record<string, unknown> = Record<string, unknown>
> extends DurableObject<Env> {
  #private;
  static options: {
    hibernate: boolean;
  };
  /**
   * Execute SQL queries against the Server's database
   * @template T Type of the returned rows
   * @param strings SQL query template strings
   * @param values Values to be inserted into the query
   * @returns Array of query results
   */
  sql<T = Record<string, string | number | boolean | null>>(
    strings: TemplateStringsArray,
    ...values: (string | number | boolean | null)[]
  ): T[];
  constructor(ctx: DurableObjectState, env: Env);
  /**
   * Handle incoming requests to the server.
   */
  fetch(request: Request): Promise<Response>;
  webSocketMessage(ws: WebSocket, message: WSMessage): Promise<void>;
  webSocketClose(
    ws: WebSocket,
    code: number,
    reason: string,
    wasClean: boolean
  ): Promise<void>;
  webSocketError(ws: WebSocket, error: unknown): Promise<void>;
  /**
   * The name for this server. Write-once-only.
   */
  get name(): string;
  setName(name: string): Promise<void>;
  /** Send a message to all connected clients, except connection ids listed in `without` */
  broadcast(
    msg: string | ArrayBuffer | ArrayBufferView,
    without?: string[] | undefined
  ): void;
  /** Get a connection by connection id */
  getConnection<TState = unknown>(id: string): Connection<TState> | undefined;
  /**
   * Get all connections. Optionally, you can provide a tag to filter returned connections.
   * Use `Server#getConnectionTags` to tag the connection on connect.
   */
  getConnections<TState = unknown>(tag?: string): Iterable<Connection<TState>>;
  /**
   * You can tag a connection to filter them in Server#getConnections.
   * Each connection supports up to 9 tags, each tag max length is 256 characters.
   */
  getConnectionTags(
    connection: Connection,
    context: ConnectionContext
  ): string[] | Promise<string[]>;
  /**
   * Execute a long-running async function while keeping the Durable Object alive.
   *
   * Durable Objects normally terminate 70-140s after the last network request.
   * This method keeps the DO alive by establishing a WebSocket connection to itself
   * and sending periodic ping messages.
   *
   * @experimental This API is experimental and may change in future versions.
   *
   * @param fn - The async function to execute
   * @param timeoutMs - Maximum time to keep the DO alive (default: 30 minutes)
   * @returns The result of the async function
   *
   * @remarks
   * Requires the `enable_ctx_exports` compatibility flag in wrangler.jsonc:
   * ```json
   * {
   *   "compatibility_flags": ["enable_ctx_exports"]
   * }
   * ```
   *
   * @example
   * ```typescript
   * const result = await this.experimental_waitUntil(async () => {
   *   // Long-running operation
   *   await processLargeDataset();
   *   return { success: true };
   * }, 60 * 60 * 1000); // 1 hour timeout
   * ```
   */
  experimental_waitUntil<T>(
    fn: () => Promise<T>,
    timeoutMs?: number
  ): Promise<T>;
  /**
   * Called when the server is started for the first time.
   */
  onStart(props?: Props): void | Promise<void>;
  /**
   * Called when a new connection is made to the server.
   */
  onConnect(
    connection: Connection,
    ctx: ConnectionContext
  ): void | Promise<void>;
  /**
   * Called when a message is received from a connection.
   */
  onMessage(connection: Connection, message: WSMessage): void | Promise<void>;
  /**
   * Called when a connection is closed.
   */
  onClose(
    connection: Connection,
    code: number,
    reason: string,
    wasClean: boolean
  ): void | Promise<void>;
  /**
   * Called when an error occurs on a connection.
   */
  onError(connection: Connection, error: unknown): void | Promise<void>;
  /**
   * Called when a request is made to the server.
   */
  onRequest(request: Request): Response | Promise<Response>;
  /**
   * Called when an exception occurs.
   * @param error - The error that occurred.
   */
  onException(error: unknown): void | Promise<void>;
  onAlarm(): void | Promise<void>;
  alarm(): Promise<void>;
}
//#endregion
export {
  Connection,
  ConnectionContext,
  ConnectionSetStateFn,
  ConnectionState,
  PartyServerOptions,
  Server,
  WSMessage,
  getServerByName,
  routePartykitRequest
};
//# sourceMappingURL=index.d.ts.map
